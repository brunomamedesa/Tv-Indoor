// ignore_for_file: avoid_print

import 'dart:async';
import 'dart:convert';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_cache_manager/flutter_cache_manager.dart';
import 'package:flutter_dotenv/flutter_dotenv.dart';
import 'package:get/get.dart';
import 'package:mobile_device_identifier/mobile_device_identifier.dart';
import 'package:dio/dio.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:tv_indoor/app/controllers/noticias_controller.dart';
import 'package:tv_indoor/app/controllers/webview_controller.dart';
import 'package:tv_indoor/app/controllers/sefaz_controller.dart';
import 'package:tv_indoor/app/utils/globals.dart';
import 'package:tv_indoor/app/utils/media_cache_manager.dart';

class ConfigController extends GetxController {
  
  final RxString deviceId = ''.obs;
  final RxBool isLoading = false.obs;
  final RxBool loadingMidias = false.obs;
  final RxMap<String, dynamic> deviceData = <String, dynamic>{}.obs;
  final RxList<RxMap<String, dynamic>> midiasCache = <RxMap<String, dynamic>>[].obs;
  final RxString versao = ''.obs;
  
  final baseUrl = kDebugMode ? dotenv.env['BASE_URL_PROD'] : dotenv.env['BASE_URL_PROD'];
  final apiKey = dotenv.env['API_KEY'];

  final dio = Dio();
  final CacheManager _mediaCache = MediaCacheManager();

  double get totalProgress {
    if (midiasCache.isEmpty) return 0.0;
    final sum = midiasCache
        .map((e) => e['progress'] as double)
        .fold(0.0, (a, b) => a + b);
    return sum / midiasCache.length;
  }

  bool get allDone => midiasCache.every((e) => (e['progress'] as double) >= 1.0);



  @override
  Future<void> onInit() async {
    super.onInit();
    print('üîß ConfigController inicializando...');
    final id = await getDeviceId();
    deviceId.value = id ?? '';
    print('üì± DeviceId obtido: ${deviceId.value}');
    
    if (deviceId.value.isEmpty) {
      print('‚ùå ERRO: DeviceId est√° vazio!');
      return;
    }
    
    await autenticarDispositivo();
  }

  void reset() {
    print('resetando');
    isLoading.value = true;
    deviceId.value = '';
    midiasCache.clear();
    midiasCache.clear();
    onInit();

  }


  Future<String?> getDeviceId() async{
    try {
      final id = await MobileDeviceIdentifier().getDeviceId();
      print('üì± MobileDeviceIdentifier retornou: $id');
      return id;
    } catch (e) {
      print('‚ùå Erro ao obter deviceId: $e');
      return null;
    }
  }

Future<void> fetchData() async {
  print('üì° Iniciando fetchData para dispositivo: ${deviceId.value}');
  print('üîó URL: $baseUrl/dispositivo/${deviceId.value}');
  
  try {
    final response = await dio.get(
      '$baseUrl/dispositivo/${deviceId.value}',
      options: Options(
        headers: {'Authorization': 'Bearer $apiKey'},
        // status ‚â• 500 n√£o lan√ßa exce√ß√£o ‚Äï‚Äê cuidaremos abaixo
        validateStatus: (code) => code != null && code < 500,
      ),
    );

    print('üì° Response recebido - Status: ${response.statusCode}');

    if (response.statusCode == 200 && response.data != null) {
      deviceData.value = response.data;          // ‚úÖ ok
      
      // LOGS DETALHADOS para debug da API
      print('‚úÖ API Response Status: ${response.statusCode}');
      print('üìä Device Data Keys: ${response.data.keys}');
      
      // Verificar cada campo individualmente
      print('üîß Dispositivo: ${response.data['dispositivo']}');
      print('üí∞ Cota√ß√µes: ${response.data['cotacoes']}');
      print('üì∞ Not√≠cias: ${response.data['noticias']}');
      print('üå§Ô∏è Previs√£o Tempo: ${response.data['previsao_tempo']}');
      print('ü•á Cota√ß√£o Metais: ${response.data['cotacao_metais']}');
      print('üé¨ M√≠dias: ${response.data['midias']}');
      
    } else {
      // resposta 404/500 ou corpo nulo
      deviceData.clear();                        // üëà nada novo
      debugPrint('‚ö†Ô∏è Backend status ${response.statusCode}');
      debugPrint('‚ö†Ô∏è Response body: ${response.data}');
    }
  } on DioException catch (e) {
    // timeout, perda de rede, etc. ‚Üí s√≥ registra, sem rethrow
    debugPrint('‚ùå Erro de rede detalhado: ${e.message}');
    debugPrint('‚ùå Tipo do erro: ${e.type}');
    debugPrint('‚ùå Response: ${e.response?.data}');
    debugPrint('‚ùå Status Code: ${e.response?.statusCode}');
    deviceData.clear();                          // mant√©m cache antigo
  } catch (e) {
    debugPrint('‚ùå Erro n√£o esperado em fetchData: $e');
    deviceData.clear();
  }
}
  Future<void> autenticarDispositivo() async {
    try {
      print('üîê Iniciando autentifica√ß√£o do dispositivo...');
      print('üì± DeviceId atual: ${deviceId.value}');
      isLoading.value = true;
      
      print('üì° Fazendo fetchData...');
      await fetchData();
      
      if (deviceData.isEmpty) {
        print('‚ùå DeviceData est√° vazio ap√≥s fetchData');
        print('‚ùå Verifique se o deviceId √© v√°lido e se a API est√° respondendo');
        return;
      }
      
      configurado.value = deviceData['configurado']; 
      print('‚öôÔ∏è Dispositivo configurado: ${configurado.value}');

      // Salvar status de configura√ß√£o localmente
      final prefs = await SharedPreferences.getInstance();
      await prefs.setBool('is_configured', configurado.value);
      await prefs.setString('device_id', deviceId.value);
      print('üíæ Configura√ß√µes locais salvas');

      print('‚è±Ô∏è Iniciando timer...');
      iniciaTimer(deviceData['dispositivo']['tempo_atualizacao']);
      
      print('üí∞ Salvando cota√ß√µes...');
      await saveCotacoes();
      
      print('üì∞ Salvando not√≠cias...');
      await saveNoticias();
      
      print('üå§Ô∏è Salvando previs√£o do tempo...');
      await savePrevisaoTempo();
      
      print('ü•á Salvando cota√ß√£o de metais...');
      await saveCotMetais();
      
      print('üèõÔ∏è Atualizando status SEFAZ...');
      await atualizarStatusSefaz();
      
      if(configurado.isTrue) {
        print('üé¨ Processando m√≠dias...');
        await handleMidias(deviceData['midias']);
        Get.back();

        if(loadingMidias.isFalse){
          print('üè† Redirecionando para TV Indoor...');
          Get.offAllNamed('/tv-indoor');
        }
      }
    } catch (e) {
      print('‚ùå Erro durante autentica√ß√£o: $e');
    } finally {
      isLoading.value = false;
      print('‚úÖ Autentica√ß√£o finalizada');
    }
    
  }
  

  Future<void> iniciaTimer(int minutos) async {
    print('print minutos: $minutos');
      final SharedPreferences prefs = await SharedPreferences.getInstance();
      prefs.setString('tempo_atualizacao', minutos.toString());
  }

  Future<bool> refreshData() async {
    try {

      isLoading.value = true;
      await fetchData();
      final existeMidiasDiferentes = await verificarMidiasAlteradas();

      configurado.value = deviceData['configurado']; 
      iniciaTimer(deviceData['dispositivo']['tempo_atualizacao']);
      await saveCotacoes();
      await saveNoticias();
      
      // Atualizar status SEFAZ junto com as outras atualiza√ß√µes
      await atualizarStatusSefaz();
      
      if(existeMidiasDiferentes) {
        await handleMidias(deviceData['midias']);
        Get.back();
      }
      isLoading.value = false;
      return existeMidiasDiferentes;

    } catch (e) {
      print(e);
      return false;
    }

  }



  Future<void> saveCotacoes() async {
      print('üí∞ Iniciando saveCotacoes...');
      final SharedPreferences prefs = await SharedPreferences.getInstance();
      var cotacoes = deviceData['cotacoes'];
      print('üí∞ Dados das cota√ß√µes recebidos da API: $cotacoes');
      
      if (cotacoes != null) {
        prefs.setString('cotacoes', jsonEncode(cotacoes));
        print('‚úÖ Cota√ß√µes salvas no SharedPreferences');
      } else {
        print('‚ùå Cota√ß√µes √© null - n√£o foi salva');
      }
      
      try {
        WebviewController webviewController = Get.find<WebviewController>();
        webviewController.getCotacoes();
        print('‚úÖ WebviewController.getCotacoes() chamado');
      } catch (e) {
        print('‚ùå Erro ao chamar WebviewController.getCotacoes(): $e');
      }
  }

  Future<void> savePrevisaoTempo() async {
      print('üå§Ô∏è Iniciando savePrevisaoTempo...');
      final SharedPreferences prefs = await SharedPreferences.getInstance();
      var previsao = deviceData['previsao_tempo'];
      print('üå§Ô∏è Dados da previs√£o recebidos da API: $previsao');
      
      if (previsao != null) {
        prefs.setString('previsao_tempo', jsonEncode(previsao));
        print('‚úÖ Previs√£o salva no SharedPreferences');
      } else {
        print('‚ùå Previs√£o √© null - n√£o foi salva');
      }
      
      try {
        WebviewController webviewController = Get.find<WebviewController>();
        webviewController.getPrevisao();
        print('‚úÖ WebviewController.getPrevisao() chamado');
      } catch (e) {
        print('‚ùå Erro ao chamar WebviewController.getPrevisao(): $e');
      }
  }

  Future<void> saveCotMetais() async {
      print('ü•á Iniciando saveCotMetais...');
      final SharedPreferences prefs = await SharedPreferences.getInstance();
      var metais = deviceData['cotacao_metais'];
      print('ü•á Dados dos metais recebidos da API: $metais');
      
      if (metais != null) {
        prefs.setString('cotacao_metais', jsonEncode(metais));
        print('‚úÖ Cota√ß√£o metais salva no SharedPreferences');
      } else {
        print('‚ùå Cota√ß√£o metais √© null - n√£o foi salva');
      }
      
      try {
        WebviewController webviewController = Get.find<WebviewController>();
        webviewController.getMetais();
        print('‚úÖ WebviewController.getMetais() chamado');
      } catch (e) {
        print('‚ùå Erro ao chamar WebviewController.getMetais(): $e');
      }
  }

  Future<void> saveNoticias() async {
      print('üì∞ Iniciando saveNoticias...');
      final SharedPreferences prefs = await SharedPreferences.getInstance();
      var noticias = deviceData['noticias'];
      print('üì∞ Dados das not√≠cias recebidos da API: $noticias');
      
      if (noticias != null) {
        prefs.setString('noticias', jsonEncode(noticias));
        print('‚úÖ Not√≠cias salvas no SharedPreferences');
      } else {
        print('‚ùå Not√≠cias √© null - n√£o foi salva');
      }
      
      try {
        // Tentar encontrar ou criar o controller
        NoticiasController noticiasController;
        if (Get.isRegistered<NoticiasController>()) {
          noticiasController = Get.find<NoticiasController>();
          print('‚úÖ NoticiasController encontrado');
        } else {
          noticiasController = Get.put(NoticiasController());
          print('‚úÖ NoticiasController criado');
        }
        
        noticiasController.getNoticias();
        print('‚úÖ NoticiasController.getNoticias() chamado');
      } catch (e) {
        print('‚ùå Erro ao trabalhar com NoticiasController: $e');
      }
  }

  Future<void> handleMidias(List<dynamic> rawMidias) async {
    // (A) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 1. Zere a lista em mem√≥ria para n√£o acumular duplicatas
    midiasCache.clear();

    // 2. Limpe (em disco) arquivos que n√£o est√£o mais na API ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // S√≥ remove arquivos de v√≠deos e imagens, URLs n√£o s√£o armazenadas em cache
    final apiUrls = rawMidias.map((m) => m['url'] as String).toSet();
    final prefs   = await SharedPreferences.getInstance();
    final stored  = prefs.getString('midias');
    if (stored != null) {
      final storedList = jsonDecode(stored) as List;
      final toRemove   = storedList
          .where((m) => !apiUrls.contains(m['url'] as String) && (m['tipo'] == 'video' || m['tipo'] == 'imagem'))
          .toList();

      print(toRemove);
      for (final rm in toRemove) {
        await _mediaCache.removeFile(rm['url'] as String);
      }
    }

    // 3. Mostre o di√°logo de progresso antes de come√ßar a baixar ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    showDownloadProgress();
    loadingMidias.value = true;

    // (B) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 4. Baixe as m√≠dias com barra de progresso (apenas v√≠deos e imagens)
    final downloadFutures = <Future<void>>[];

    for (final m in rawMidias) {
      final entrada = <String, dynamic>{
        'tipo'            : m['tipo'],
        'url'             : m['url'],
        'file'            : null,
        'progress'        : 0.0,
        'qlik_integration': m['qlik_integration'] ?? false,
        'url_externa'     : m['url_externa'],
        'url_original'    : m['url_original'],
      }.obs;
      midiasCache.add(entrada);

      if (m['tipo'] == 'video' || m['tipo'] == 'imagem') {
        // Download apenas para v√≠deos e imagens
        final c = Completer<void>();
        downloadFutures.add(c.future);

        _mediaCache.getFileStream(m['url'], withProgress: true).listen((resp) {
          if (resp is DownloadProgress) {
            final pct = resp.totalSize != null
                ? resp.downloaded / resp.totalSize!
                : 0.0;
            entrada['progress'] = pct;
            entrada.refresh();
          } else if (resp is FileInfo) {
            entrada['file']     = resp.file.path;
            entrada['progress'] = 1.0;
            entrada.refresh();
            c.complete();
          }
        });
      } else if (m['tipo'] == 'url') {
        // URLs s√£o "baixadas" instantaneamente
        entrada['progress'] = 1.0;
        entrada['file'] = m['url']; // Para URLs, o "file" √© a pr√≥pria URL
        entrada.refresh();
      }
    }

    await Future.wait(downloadFutures);

    // (C) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // 5. Gere lista "limpa" (sem progress, sem Rx) p/ gravar no prefs
    final listaParaPrefs = [
      for (final rx in midiasCache)
        {
          'tipo'            : rx['tipo'],
          'url'             : rx['url'],
          'file'            : rx['file'],
          'qlik_integration': rx['qlik_integration'] ?? false,
          'url_externa'     : rx['url_externa'],
          'url_original'    : rx['url_original'],
        }
    ];
    await prefs.setString('midias', jsonEncode(listaParaPrefs));

    // 6. Feche di√°logo e sinalize fim
    loadingMidias.value = false;
    Get.back();                       // fecha o AlertDialog de download
  }

  // Future<void> handleMidias(List<dynamic> rawMidias) async {

  //   midiasCache.clear();
  //   final Set<String> apiUrls = rawMidias
  //     .map((m) => m['url'] as String)
  //     .toSet();

  //   final SharedPreferences prefs = await SharedPreferences.getInstance();

  //   final items =  prefs.getString('midias');
  //   if(items != null) {
  //     final itemsDecoded = jsonDecode(items) as List;
    
  //     final toRemove = itemsDecoded
  //       .where((m) => !apiUrls.contains(m['url'] as String))
  //       .toList();  // <‚Äî materializa
        
  //     print('remover: $toRemove');

  //     for (final rm in toRemove) {
  //       final url = rm['url'] as String;
  //       await _mediaCache.removeFile(url);
  //       itemsDecoded.removeWhere((e) => e['url'] == url);
  //     }

  //     prefs.setString('midias', jsonEncode(itemsDecoded));
  //     showDownloadProgress();
  //   }
    
  //   loadingMidias.value = true;

  //   final futures = <Future<void>>[];

  //   for (var m in rawMidias) {
  //     final url   = m['url']   as String;
  //     final tipo  = m['tipo']  as String;

  //     // 1) Cria o RxMap e adiciona na RxList
  //     final entrada = <String, dynamic>{
  //       'tipo': tipo,
  //       'url': url,
  //       'file': null,
  //       'progress': 0.0,
  //     }.obs;

  //     midiasCache.add(entrada);

  //     // cria um Completer que vamos completar no evento FileInfo
  //     final completer = Completer<void>();
  //     futures.add(completer.future);

  //     // 2) Pega o stream de download com progresso
  //     final stream = _mediaCache.getFileStream(url, withProgress: true);

  //     // 3) Escuta o stream

  //     stream.listen((resp) {
  //       if (resp is DownloadProgress) {
  //         final pct = resp.totalSize != null
  //             ? resp.downloaded / resp.totalSize!
  //             : 0.0;
  //         entrada['progress'] = pct;
  //         entrada.refresh();

  //       } else if (resp is FileInfo) 
  //       {
  //         entrada['file'] = resp.file.path;
  //         entrada['progress'] = 1.0;
  //         entrada.refresh();
  //         completer.complete();  
  //                 // sinaliza que esse download acabou
  //       }
  //     });
  //   }

  //   await Future.wait(futures);
  //   prefs.setString('midias', jsonEncode(midiasCache));
  //   loadingMidias.value = false;
  //   return;

  // }

  //SEMPRE QUE CHAMAR, CERTIFICAR DE CHAMAR FETCH DATA ANTES
  Future<bool> verificarMidiasAlteradas() async {

    // 2) Extrai lista de URLs da API
    final List<dynamic> apiMidias = deviceData['midias'] as List<dynamic>;
    final Set<String> apiUrls = apiMidias
        .map((m) => m['url'] as String)
        .toSet();

    // 3) Busca o JSON armazenado em SharedPreferences
    final SharedPreferences prefs = await SharedPreferences.getInstance();
    final String? storedJson = prefs.getString('midias');

    // Se n√£o houver nada armazenado, considera altera√ß√£o se a API retornar alguma m√≠dia
    if (storedJson == null) {
      return apiUrls.isNotEmpty;
    }

    // 4) Decodifica o JSON salvo e extrai as URLs
    final List<dynamic> storedList = jsonDecode(storedJson) as List<dynamic>;
    final Set<String> storedUrls = storedList
        .map((m) => (m as Map<String, dynamic>)['url'] as String)
        .toSet();

    // 5) Compara os dois conjuntos de URLs
    // setEquals vem de 'package:flutter/foundation.dart'
    return !setEquals(apiUrls, storedUrls);
  }

  // M√©todo para buscar URL do Qlik com ticket
  Future<String?> getQlikUrl(String qlikApiUrl) async {
    try {
      final response = await dio.get(
        qlikApiUrl,
        options: Options(
          headers: {'Authorization': 'Bearer $apiKey'},
          validateStatus: (code) => code != null && code < 500,
        ),
      );

      if (response.statusCode == 200 && response.data != null) {
        final data = response.data;
        if (data['success'] == true && data['ready_to_use'] == true) {
          return data['qlik_url'] as String?;
        }
      }
      return null;
    } on DioException catch (e) {
      debugPrint('‚ö†Ô∏è Erro ao buscar URL do Qlik: $e');
      return null;
    }
  }

  void showDownloadProgress() {
    Get.dialog(
      AlertDialog(
        title: const Text('Baixando m√≠dias'),
        content: SizedBox(
          width: 400,
          height: 50, // espa√ßo suficiente
          child: Obx(() {
            // pega o total agregado
            final pct = totalProgress;
            final label = allDone
              ? 'Conclu√≠do!'
              : 'Baixando m√≠dias: ${(pct * 100).toStringAsFixed(0)}%';
            return Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                Text(label),
                const SizedBox(height: 16),
                LinearProgressIndicator(value: pct),
              ],
            );
          }),
        ),
      ),
      barrierDismissible: false,
    );
  }

  Future<void> atualizarStatusSefaz() async {
    try {
      // Tentar encontrar ou criar o SefazController
      SefazController sefazController;
      if (Get.isRegistered<SefazController>()) {
        sefazController = Get.find<SefazController>();
        print('‚úÖ SefazController encontrado');
      } else {
        sefazController = Get.put(SefazController());
        print('‚úÖ SefazController criado');
      }
      
      await sefazController.atualizarAgora();
      print('‚úÖ Status SEFAZ atualizado');
    } catch (e) {
      print('‚ùå Erro ao atualizar status SEFAZ: $e');
    }
  }

}